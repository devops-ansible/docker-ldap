#!/usr/bin/env bash

# kill script when error occurs
set -e

ulimit -n ${LDAP_ULIMIT}
export EP_PID=$$
export ep_lockfile="/entrypoint.lock"

# if starting with test mode, run testing
if [ "${1}" == "test" ]; then

    export PATH="${PATH}:${TESTS_PATH}/bats/bin/"
    cd "${TESTS_PATH}"
    bats --trace ./test.bats

# in any other case do regular startup
else

    if { [ -z ${TESTRUN+x} ];  } || { { ! [ "${TESTRUN}" = "true" ]; } && { ! [ "${TESTRUN}" = "yes" ]; } } then
        # Since especially the `900_ldap_boot.sh` does export
        # env vars, we need to source the `/boot.sh`.
        # For that, we also need to change back to working dir after
        # running bootup tasks.
        workingDir="$( pwd )"
        source /boot.sh
        cd "${workingDir}"
    fi

    # if given CMD is `start` do
    if [ "${1}" == "start" ]; then

        if [ -f "${ep_lockfile}" ]; then
            echo -e "\033[1;30;41m \`entrypoint start\` may only be run once at a time ... \033[0m"
            exit 1
        fi

        touch "${ep_lockfile}"

        _slapdPid() {
            slapdPid="$( pgrep slapd )"
            if [ "$?" -eq 0 ]; then
                echo "${slapdPid}"
            else
                return 1
            fi
        }

        _term() {
            rm -f "${ep_lockfile}"
            slapdPid="$( _slapdPid )"
            if [ "$?" -eq 0 ]; then
                # clean termination of slapd
                kill -TERM "${slapdPid}" 2&> /dev/null
            fi
            # wait until slapd has ended
            set +e # `_slapdPid` may return another rc then 0 ... so don't break the whole script here!
            _slapdPid 1&> /dev/null
            while [ "$?" == 0 ]; do
                _slapdPid 1&> /dev/null
            done
            set -e
            # return TERM exit code
            exit 143 # 128 + 15 -- SIGTERM
        }

        # do the regular LDAP startup in foreground for docker container
        # to stay alive – for that, the loglevel has to be defined.
        start_slapd &

        # clean handling of termination signals
        # SIGKILL isn't handled cleanly ...
        trap _term SIGTERM SIGINT SIGQUIT SIGHUP

        # keep slapd running – while true necessary since slapd
        # is started as “background” process
        while true; do
            # wait for next check
            sec="${RUNNING_CHECK}"
            while [ ${sec} -ge 0 ]; do
                # run within `while` loop for container being able to
                # handle SIGTERM correctly in a timely manner
                sleep 1
                let "sec=sec-1"
            done
            # do the check if slapd still running
            set +e # `_slapdPid` may return another rc then 0 ... so don't break the whole script here!
            _slapdPid 1&> /dev/null
            rc="$?"
            set -e
            # slapd has been stopped for some reason ... so now restart slapd
            if [ "${rc}" -ne 0 ]; then
                echo "rc was ${rc}"
                start_slapd &
            fi
        done
    else
        # another CMD was given, so the container will execute that one
        exec "$@"
    fi
fi
